// Global variables
let brainCells = 0; // Current number of BrainCells
let bcps = 0; // BrainCells per second
let upgrades = [
  { name: "Meme", cost: 10, baseCost: 10, bcps: 0.1, count: 0 },
  { name: "TikTok", cost: 100, baseCost: 100, bcps: 1, count: 0 },
  { name: "Doomscroller", cost: 1000, baseCost: 1000, bcps: 10, count: 0 }
]; // Array of upgrade objects
let brainSize = 100; // Base size of the brain

// Setup function - runs once at the start
function setup() {
  createCanvas(600, 400); // Create a 600x400 pixel canvas
  textAlign(CENTER, CENTER); // Center-align text both horizontally and vertically
  textSize(16); // Default text size
  frameRate(30); // Set frame rate to 30 FPS
}

// Draw function - game loop, runs every frame
function draw() {
  background(220); // Light gray background
  
  // Update BrainCells based on BCPS (30 FPS)
  brainCells += bcps / 30;
  
  // Draw the brain with pulsating effect
  let pulse = sin(frameCount * 0.05) * 10; // Pulsation based on frame count
  fill(255, 150, 150); // Light pink fill for brain
  stroke(200, 100, 100); // Darker pink outline
  strokeWeight(2); // Outline thickness
  ellipse(width / 2, height / 2 - 50, brainSize + pulse, brainSize + pulse); // Draw brain
  
  // Draw brain lines to simulate folds
  for (let i = 0; i < 8; i++) {
    let angle = map(i, 0, 8, 0, TWO_PI); // Map 8 lines around the circle
    let x1 = width / 2 + cos(angle) * (brainSize / 3 + pulse / 3);
    let y1 = height / 2 - 50 + sin(angle) * (brainSize / 3 + pulse / 3);
    let x2 = width / 2 + cos(angle) * (brainSize / 2 + pulse / 2);
    let y2 = height / 2 - 50 + sin(angle) * (brainSize / 2 + pulse / 2);
    line(x1, y1, x2, y2); // Draw each fold line
  }
  
  // Draw instruction text below brain
  fill(0); // Black text
  noStroke(); // Remove outline for text
  text("Click to Restore!", width / 2, height / 2 + 20);
  text("Made by Ryan N with Grok", width / 2, height / 2 + 170);
  // Draw stats at the top
  textSize(20); // Larger text for stats
  text(`BrainCells: ${floor(brainCells)}`, width / 2, 20); // Display integer BrainCells
  text(`BCPS: ${bcps.toFixed(1)}`, width / 2, 50); // Display BCPS with 1 decimal
  
  // Draw upgrade buttons on the right
  for (let i = 0; i < upgrades.length; i++) {
    let u = upgrades[i];
    let x = width - 150; // Position 150 pixels from right edge
    let y = 100 + i * 70; // Stack vertically with 70px spacing
    
    // Check if mouse is hovering over the button
    let isHover = mouseX > x && mouseX < x + 140 && mouseY > y && mouseY < y + 60;
    fill(isHover ? 180 : 150); // Lighter gray if hovered, darker if not
    stroke(100); // Dark gray outline
    strokeWeight(1); // Thin outline
    rect(x, y, 140, 60, 10); // Draw button with rounded corners
    
    // Draw upgrade text
    fill(0); // Black text
    noStroke();
    textSize(14); // Smaller text for buttons
    text(`${u.name} (${u.count})`, x + 70, y + 15); // Name and count
    text(`Cost: ${floor(u.cost)} BC`, x + 70, y + 30); // Current cost
    text(`+${u.bcps} BCPS`, x + 70, y + 45); // BCPS gain
  }
  
  // Smoothly decrease brainSize back to 100 after click
  if (brainSize > 100) {
    brainSize -= 1;
  }
}

// Mouse pressed function - handles clicks
function mousePressed() {
  // Check if clicked on brain
  let d = dist(mouseX, mouseY, width / 2, height / 2 - 50);
  if (d < 60) { // Fixed click radius for consistency
    brainCells += 1; // Add 1 BrainCell per click
    brainSize = 120; // Enlarge brain for feedback
  }
  
  // Check if clicked on upgrade buttons
  for (let i = 0; i < upgrades.length; i++) {
    let u = upgrades[i];
    let x = width - 150;
    let y = 100 + i * 70;
    if (mouseX > x && mouseX < x + 140 && mouseY > y && mouseY < y + 60) {
      if (brainCells >= u.cost) { // Check if player has enough BrainCells
        brainCells -= u.cost; // Deduct cost
        bcps += u.bcps; // Add BCPS
        u.count++; // Increment purchase count
        u.cost = u.baseCost * pow(1.15, u.count); // Update cost exponentially
      }
    }
  }
}
